// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.Build.Framework;
using Microsoft.Build.Utilities;
using Microsoft.NET.Sdk.WorkloadManifestReader;

namespace Microsoft.DotNet.Build.Tasks.Workloads
{
    /// <summary>
    /// MSBuild task to generate a workload pack installer (MSI).
    /// </summary>
    public class GenerateWorkloadPackMsi : GenerateTaskBase
    {
        /// <summary>
        /// The name of the ComponentGroup generated by Heat.
        /// </summary>
        internal const string PackageContentComponentGroupName = "CG_PackageContent";

        /// <summary>
        /// The DirectoryReference to use as the parent for harvested directories.
        /// </summary>
        internal const string PackageContentDirectoryReference = "VersionDir";

        /// <summary>
        /// The default set of platforms to use for building MSIs.
        /// </summary>
        internal static readonly string[] MsiPlatforms = new string[] { "x86", "x64", "arm64" };

        /// <summary>
        /// The UUID namespace to use for generating a product code.
        /// </summary>
        internal static readonly Guid ProductCodeNamespaceUuid = Guid.Parse("3B04DD8B-41C4-4DA3-9E49-4B69F11533A7");

        /// <summary>
        /// The UUID namesapce to use for generating an upgrade code.
        /// </summary>
        internal static readonly Guid UpgradeCodeNamespaceUuid = Guid.Parse("C743F81B-B3B5-4E77-9F6D-474EFF3A722C");

        /// <summary>
        /// Wildcard patterns of files that should be removed from packages prior to harvesting.
        /// </summary>
        public ITaskItem[] ExcludeFiles
        {
            get;
            set;
        } = Array.Empty<ITaskItem>();

        /// <summary>
        /// The root installation directory, relative to DOTNET_HOME, e.g. "packs" or "sdk". This value is only used when converting a single
        /// NuGet package.
        /// </summary>
        public string InstallDir
        {
            get;
            set;
        } = "packs";

        public bool GenerateSwixAuthoring
        {
            get;
            set;
        }

        /// <summary>
        /// The workload manifests files to process.
        /// </summary>
        public ITaskItem[] WorkloadManifests
        {
            get;
            set;
        }

        /// <summary>
        /// The set of MSIs that were produced.
        /// </summary>
        [Output]
        public ITaskItem[] Msis
        {
            get;
            private set;
        }

        /// <summary>
        /// The path where the generated MSIs will be placed.
        /// </summary>
        [Required]
        public string OutputPath
        {
            get;
            set;
        }

        /// <summary>
        /// The path where the packages referenced by the manifest files are located.
        /// </summary>
        public string PackagesPath
        {
            get;
            set;
        }

        /// <summary>
        /// The path of the NuGet package to harvest.
        /// </summary>
        public string SourcePackage
        {
            get;
            set;
        }

        public override bool Execute()
        {
            try
            {
                EmbeddedTemplates.Log = Log;
                List<ITaskItem> msis = new();

                if (WorkloadManifests is not null)
                {
                    if (string.IsNullOrWhiteSpace(PackagesPath))
                    {
                        Log.LogError($"{nameof(PackagesPath)} parameter cannot be null or empty.");
                    }

                    foreach (WorkloadPackMsiData data in GetWorkloadPacks())
                    {
                        msis.AddRange(GenerateMsi(data.SourcePackage, OutputPath, data.Platforms, data.InstallDir));
                    }
                }
                else if (!string.IsNullOrWhiteSpace(SourcePackage))
                {
                    msis.AddRange(GenerateMsi(SourcePackage, OutputPath, MsiPlatforms, InstallDir));
                }
                else
                {
                    Log.LogError("Either SourcePackage or ManifestFiles parameters must be specified.");
                }

                Msis = msis.ToArray();
            }
            catch (Exception e)
            {
                Log.LogMessage(MessageImportance.Low, e.StackTrace);
                Log.LogErrorFromException(e);
            }

            return !Log.HasLoggedErrors;
        }

        /// <summary>
        /// Generate a single MSI, for a single platform.
        /// </summary>
        /// <param name="sourcePackage"></param>
        /// <param name="outputPath"></param>
        /// <param name="platforms"></param>
        private IEnumerable<ITaskItem> GenerateMsi(string sourcePackage, string outputPath, string[] platforms, string installDir)
        {
            NugetPackage nupkg = new(sourcePackage, Log);
            List<TaskItem> msis = new();

            // MSI ProductName defaults to the package title and fallback to the package ID with a warning.
            string productName = nupkg.Title;

            if (string.IsNullOrWhiteSpace(nupkg.Title))
            {
                Log?.LogWarning($"'{sourcePackage}' should have a non-empty title. The MSI ProductName will be set to the package ID instead.");
                productName = nupkg.Id;
            }

            // Extract once. We have to harvest multiple times because the platform changes some attributes. 
            string packageContentsDirectory = Path.Combine(IntermediateBaseOutputPath, "pkg", $"{nupkg.Identity}");
            IEnumerable<string> exclusions = GetExlusionPatterns();
            Log.LogMessage(MessageImportance.Low, $"Extracting '{SourcePackage}' to '{packageContentsDirectory}'");
            nupkg.Extract(packageContentsDirectory, exclusions);

            foreach (string platform in platforms)
            {
                string tempName = Utils.GetHash($"{nupkg.Id};{nupkg.Version};{platform}", "MD5");

                // Extract the MSI template and add it to the list of source files.
                List<string> sourceFiles = new();
                string templateSourcePath = Path.Combine(SourceDirectory, tempName);
                sourceFiles.Add(EmbeddedTemplates.Extract("DependencyProvider.wxs", templateSourcePath));
                sourceFiles.Add(EmbeddedTemplates.Extract("Directories.wxs", templateSourcePath));
                sourceFiles.Add(EmbeddedTemplates.Extract("Product.wxs", templateSourcePath));
                sourceFiles.Add(EmbeddedTemplates.Extract("Registry.wxs", templateSourcePath));
                EmbeddedTemplates.Extract("Variables.wxi", templateSourcePath);

                // Harvest the package contents and add it to the source files we need to compile.
                string packageContentWxs = Path.Combine(templateSourcePath, "PackageContent.wxs");
                sourceFiles.Add(packageContentWxs);

                HarvestToolTask heat = new(BuildEngine, WixToolsetPath)
                {
                    ComponentGroupName = PackageContentComponentGroupName,
                    DirectoryReference = PackageContentDirectoryReference,
                    OutputFile = packageContentWxs,
                    Platform = platform,
                    SourceDirectory = packageContentsDirectory
                };

                if (!heat.Execute())
                {
                    throw new Exception($"Failed to harvest package contents.");
                }

                // Compile the MSI sources
                string candleIntermediateOutputPath = Path.Combine(IntermediateBaseOutputPath, "wixobj", tempName);

                CompileToolTask candle = new(BuildEngine, WixToolsetPath)
                {
                    // Candle expects the output path to end with a single '\'
                    OutputPath = candleIntermediateOutputPath.TrimEnd(Path.DirectorySeparatorChar) + Path.DirectorySeparatorChar,
                    SourceFiles = sourceFiles,
                    Arch = platform
                };

                // Configure preprocessor definitions. 
                string manufacturer = "Microsoft Corporation";

                if (!string.IsNullOrWhiteSpace(nupkg.Authors) && (nupkg.Authors.IndexOf("Microsoft", StringComparison.OrdinalIgnoreCase) < 0))
                {
                    manufacturer = nupkg.Authors;
                }
                Log.LogMessage(MessageImportance.Low, $"Setting Manufacturer to '{manufacturer}'");

                candle.PreprocessorDefinitions.AddRange(GetPreprocessorDefinitions(nupkg, platform));
                candle.PreprocessorDefinitions.Add($@"InstallDir={installDir}");
                candle.PreprocessorDefinitions.Add($@"ProductName={productName}");
                candle.PreprocessorDefinitions.Add($@"Platform={platform}");
                candle.PreprocessorDefinitions.Add($@"SourceDir={packageContentsDirectory}");
                candle.PreprocessorDefinitions.Add($@"Manufacturer={manufacturer}");

                // Compiler extension to process dependency provider authoring for package reference counting.
                candle.Extensions.Add("WixDependencyExtension");

                if (!candle.Execute())
                {
                    throw new Exception($"Failed to compile MSI.");
                }

                // Link the MSI. The generated filename contains a the semantic version (excluding build metadata) and platform. 
                string outputFile = Path.Combine(OutputPath, Path.GetFileNameWithoutExtension(sourcePackage) + $"-{platform}.msi");

                LinkToolTask light = new(BuildEngine, WixToolsetPath)
                {
                    OutputFile = Path.Combine(OutputPath, outputFile),
                    SourceFiles = Directory.EnumerateFiles(candleIntermediateOutputPath, "*.wixobj")
                };

                // Add WiX extensions
                light.Extensions.Add("WixDependencyExtension");
                light.Extensions.Add("WixUIExtension");

                if (!light.Execute())
                {
                    throw new Exception($"Failed to link MSI.");
                }

                TaskItem msi = new TaskItem(light.OutputFile);
                msi.SetMetadata("Platform", platform);
                msis.Add(msi);

                if (GenerateSwixAuthoring)
                {
                    GenerateSwixPackageAuthoring(light.OutputFile, $"{nupkg.Id}", platform);
                }
            }

            return msis;
        }

        public void GenerateSwixPackageAuthoring(string msiPath, string packageId, string platform)
        {
            GenerateVisualStudioMsiPackageProject swixTask = new()
            {                
                Chip = platform,
                IntermediateBaseOutputPath = this.IntermediateBaseOutputPath,
                PackageName = packageId,
                MsiPath = msiPath,
            };

            swixTask.BuildEngine = BuildEngine;

            if (!swixTask.Execute())
            {
                Log.LogError($"Failed to generate SWIX authoring for '{msiPath}'");
            }            
        }

        private IEnumerable<string> GetExlusionPatterns()
        {
            IEnumerable<string> patterns = ExcludeFiles.Select(
                e => Utils.ConvertToRegexPattern(e.ItemSpec)) ?? Enumerable.Empty<string>();

            foreach (string pattern in patterns)
            {
                Log.LogMessage(MessageImportance.Low, $"Adding exclusion pattern: {pattern}");
            }

            return patterns;
        }

        /// <summary>
        /// Generate a set of preprocessor variable definitions using the metadata.
        /// </summary>
        /// <returns>An enumerable containing package metadata converted to WiX preprocessor definitions.</returns>
        private IEnumerable<string> GetPreprocessorDefinitions(NugetPackage package, string platform)
        {
            yield return $@"PackageId={package.Id}";
            yield return $@"PackageVersion={package.Version}";
            yield return $@"ProductVersion={package.Version.Major}.{package.Version.Minor}.{package.Version.Patch}";
            yield return $@"ProductCode={Utils.CreateUuid(ProductCodeNamespaceUuid, package.Identity.ToString() + $"{platform}"):B}";
            yield return $@"UpgradeCode={Utils.CreateUuid(UpgradeCodeNamespaceUuid, package.Identity.ToString() + $"{platform}"):B}";
        }

        private IEnumerable<WorkloadPackMsiData> GetWorkloadPacks()
        {
            Dictionary<string, WorkloadPackMsiData> msiPacks = new();

            foreach (ITaskItem manifestFile in WorkloadManifests)
            {
                Log?.LogMessage(MessageImportance.Low, $"Processing {manifestFile}");
                WorkloadManifest manifest = WorkloadManifestReader.ReadWorkloadManifest(File.OpenRead(manifestFile.ItemSpec));

                foreach (WorkloadPackId packId in manifest.Packs.Keys)
                {
                    WorkloadPack pack = manifest.Packs[packId];

                    if (!pack.IsAlias)
                    {
                        // Need to generate x86, x64 and arm64 MSI
                        string sourcePackage = Path.Combine(PackagesPath, $"{pack.Id}.{pack.Version}.nupkg");

                        if (!File.Exists(sourcePackage))
                        {
                            throw new FileNotFoundException($"Cannot find source package: {sourcePackage}");
                        }

                        if (!msiPacks.ContainsKey(sourcePackage))
                        {
                            msiPacks[sourcePackage] = new WorkloadPackMsiData { SourcePackage = sourcePackage, InstallDir = GetInstallDir(pack.Kind), Platforms = MsiPlatforms };
                        }
                    }
                    else
                    {
                        // Only generate MSIs for the provided RIDs
                    }
                }
            }

            return msiPacks.Values;
        }

        private string GetInstallDir(WorkloadPackKind kind)
        {
            switch (kind)
            {
                case WorkloadPackKind.Framework:
                case WorkloadPackKind.Sdk:
                    return "packs";
                case WorkloadPackKind.Library:
                    return "library-packs";
                case WorkloadPackKind.Template:
                    return "templates";
                case WorkloadPackKind.Tool:
                    return "tool-packs";
                default:
                    throw new ArgumentException($"Unknown package kind: {kind}");
            }
        }       
    }
}
